    private static boolean isRoot(NetworkClientEntity entity) {
        return entity.getUpperClientEntity() == null;
    }

    //még a törlés előtt kell meghívni
    private static boolean willBeNewRootCreatedAfterRemove(NetworkClientEntity entity) {
        if (entityTree.getRoot().getID().equals(entity.getID())) {
            return true;
        }
        if (entityTree.isInPathBetween(entityTree.getNetworkClientEntity(UserID.getUserID()),
                entityTree.getRoot(),
                entity)) {
            return true;
        }
        return false;
    }

    private static void removeEntityIfThereWillBeNoNewRoot(NetworkClientEntity entity) {
        entityTree.removeNetworkClientEntity(entity);
    }

    private static NetworkClientEntity searchNewRootUnderEntity(NetworkClientEntity entity) {
        return entityTree.getChildUnderEntityOnPathBetween(entityTree.getNetworkClientEntity(UserID.getUserID()),
                entityTree.getRoot(),
                entity);
    }


    private static void removeEntityIfThereWillBeNewRoot(NetworkClientEntity entity) {
        NetworkClientEntity newRoot = searchNewRootUnderEntity(entity);
        entityTree.removeNetworkClientEntityWithException(entityTree.getRoot(), newRoot);
        entityTree.setRoot(newRoot);
    }

    //hozzáadás előtt kell megíhvni
    private static boolean willBeNewRootCreatedAfterAdd(NewClientSignal signal) {
        if(signal.getClientID().equals(entityTree.getRoot().getID())) {
            return true;
        }
        return false;
    }

    /*public static void propagateAllClientInfo() {
            for (NetworkClientEntity act : entityTree.getAllClients()) {
                forwardMessageDownwardsWithException(new NewClientSignal(act.getID(),
                                act.getNickname(), act.getIP(), act.getPort(),
                                act.getMementoNumber(), act.getUpperClientID()).toString(),
                        act.getID());
                forwardMessageUpwards(new NewClientSignal(act.getID(),
                        act.getNickname(), act.getIP(), act.getPort(),
                        act.getMementoNumber(),
                        act.getUpperClientID()).toString());
            }
        }*/


         /*public static void sendMementoOpenerSignalToClient(UUID userID,UUID mementoID) {
                sendMessageToClient(userID,getMementoOpenerSignal(userID, mementoID));
            }

            public static void sendMementoCloserSignalToClient(UUID userID,UUID mementoID) {
                sendMessageToClient(userID,getMementoCloserSignal(userID, mementoID));
            }*/

            /*private static void reconnectToAnotherNetworkClient() {
                for(NetworkClientEntity act : allNetworkClients) {
                    if(act.hasOpenedPort()){
                        try {connect(act.getIP(),act.getPort());}
                        catch (IOException e) {
                            System.out.println("reconnection failed with: "+act.getID());
                            continue;
                        }
                        System.out.println("reconnection succesfull with: "+act.getID());
                        return;
                    } else {
                        System.out.println("doesn't have opened port: "+act.getID());
                    }
                }
            }*/


             /*if(connectedClientEntity == null && lowerConnectedClientEntities.isEmpty() ) {
                    reconnectToAnotherNetworkClient();
                }*/




 //épp most lesz új root, mert én voltam, és én csatlakozok
        if(amiRootBeforeHandshaking) {
            NetworkService.sendEntityTreeSignal(true);
        }

        if(!NetworkService.amiRoot() && imServer) {
            Signal newClientSignal = new NewClientSignal(
                    remoteHandshakingInfo.getID(),
                    remoteHandshakingInfo.getNickname(),
                    remoteHandshakingInfo.getIP(),
                    remoteHandshakingInfo.getPort(),
                    remoteHandshakingInfo.getMementoNumber(),
                    remoteHandshakingInfo.getUpperClientID());
            NetworkService.sendSignalUpwards(newClientSignal);
        }

package com.sharedtable.model.signals;

import java.util.UUID;

public class RootSignal implements Signal {

    public RootSignal(UUID newRootID) {
        this.newRootID = newRootID;
    }

    public RootSignal(String[] input) {
        newRootID = UUID.fromString(input[2]);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("SIG;NEWROOT;").append(newRootID);
        return sb.toString();
    }

    public UUID getNewRootID() {
        return newRootID;
    }

    public void setNewRootID(UUID newRootID) {
        this.newRootID = newRootID;
    }

    private UUID newRootID;
}











package com.sharedtable.model.signals;

import com.sharedtable.controller.commands.Command;
import com.sharedtable.controller.commands.CommandFactory;
import com.sharedtable.model.ArrayPrinter;

import java.util.ArrayList;
import java.util.UUID;

public class SyncSignal implements Signal {

    public SyncSignal(UUID creatorID) {
        this.creatorID = creatorID;
    }


    public SyncSignal(String[] input) {
        String[] sections = input;
        String[] header = sections[0].split(";");
        creatorID = UUID.fromString(header[1]);
        processSignals(sections[1]);
        processCommands(sections[2]);
    }

    public UUID getCreatorID() {
        return creatorID;
    }

    public void addCommand(Command command) {
        commands.add(command);
    }

    public void addSignal(Signal signal) {
        signals.add(signal);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("SIG;SYNC;").append(creatorID).append("||");

        for(Signal act : signals) {
            sb.append(act.toString()).append("|");
        }
        sb.append("||");
        for(Command act : commands) {
            sb.append(act.toString()).append("|");
        }
        return sb.toString();
    }

    private void processSignals(String input) {
        String[] signalStrings = input.split("|");
        for(String act : signalStrings) {
            signals.add(SignalFactory.getSignal(act.split(";")));
        }
    }

    private void processCommands(String input) {
        String[] commandStrings = input.split("|");
        for(String act : commandStrings) {
            commands.add(CommandFactory.getCommand(act.split(";")));
        }
    }

    private ArrayList<Command> commands = new ArrayList<>();
    private ArrayList<Signal> signals = new ArrayList<>();
    private UUID creatorID;


}













//////////////////////////////



private SyncedSignal addMenentoToSyncSignal(StateMemento stateMemento, UUID canvasID, SyncedSignal inp) {
        ArrayList<Command> cmds = stateMemento.getCommands();
        boolean isLinked = stateMemento.getPreviousMemento() != null;
        //inp.addSignal(new MementoOpenerSignal(stateMemento.getCreatorID(),canvasID,stateMemento.getId(),isLinked));
        for(Command act : cmds) {
            inp.addCommand(act);
        }
        //inp.addSignal(new MementoCloserSignal(stateMemento.getCreatorID(),canvasID,stateMemento.getId(),isLinked));
        return inp;
    }

    private SyncedSignal addAllMementosOnCanvasToSyncSignal(CanvasController canvasController, SyncedSignal inp) {
        ArrayList<StateMemento> mementos = canvasController.getMementos();
        for(int i=1; i<mementos.size(); i++) {
            addMenentoToSyncSignal(mementos.get(i),canvasController.getCanvasID(),inp);
        }
        return inp;
    }

    private SyncedSignal addSynchronizationCommands(SyncedSignal inp) {
        for(CanvasController act : TabController.getAllCanvasControllers()) {
            addAllMementosOnCanvasToSyncSignal(act,inp);
            inp.addCommand(new ChangeStateCommand(act,UserID.getUserID(),act.getCurrentMementoID()));
        }
        return inp;
    }

    private SyncedSignal addTabSynchronizationCommands(SyncedSignal inp) {
        for(NewTabSignal act : TabController.generateNewTabSignalsFromAllTab()) {
            inp.addSignal(act);
        }
        return inp;
    }

    private SyncedSignal generateSyncSignal() {
        SyncedSignal res = new SyncedSignal(UserID.getUserID());
        res = addTabSynchronizationCommands(res);
        res = addSynchronizationCommands(res);
        return res;
    }

    private SyncedSignal receiveSyncSignal() {
        SyncedSignal remoteSyncedSignal;
        if(scanner.hasNext()) {
            remoteSyncedSignal = new SyncedSignal(scanner.nextLine().split("||"));
        } else {
            throw new RuntimeException("connection dropped during handshakingProcess");
        }
        return remoteSyncedSignal;
    }


    input.setWidth(Math.abs(input.getWidth()-input.getX()));
    input.setHeight(Math.abs(input.getHeight()-input.getY()));
    input.setX(input.getX() <= input.getWidth() ? input.getX() : input.getWidth());
    input.setY(input.getY() <= input.getHeight() ? input.getY() : input.getHeight());


private Rectangle fixNegativeWidthHeight(Rectangle input) {
        double x1 = input.getX();
        double y1 = input.getY();
        double x2 = input.getX()+input.getWidth();
        double y2 = input.getY()+input.getY();

        double resx1=0;
        double resy1=0;
        double resx2=0;
        double resy2=0;


        if(input.getWidth() >=0 && input.getHeight() >=0)
            return input;
        if(input.getHeight()<0) {
            System.out.println(new Rectangle(x1,y1 + input.getHeight(),input.getWidth(),(input.getHeight()*-1)));
            return new Rectangle(x1,y1 + input.getHeight(),input.getWidth(),(y1 + input.getHeight())*-1);
        }

        return new Rectangle(resx1,resy1,resx1+resx2,resy1+resy2);
    }


    //TODO #7 ellipszis DONE; téglalap DONE; háromszög DONE; image pastealmost done
        //TODO #8
        //TODO #9 háromszög DONE
        //TODO ## scrollable chat flow
        //TODO ## image paste

        private String byteArrayToString(byte[] input) {
                return new String(input, StandardCharsets.UTF_8);
            }

            private byte[] stringToByteArray(String input) {
                return input.getBytes(StandardCharsets.UTF_8);
            }


if(!(signal instanceof DiscoverySignal) &&
                            !(signal instanceof NewClientSignal) &&
                            !(signal instanceof ByteReceiveReadySignal))
                    {

/*
    private void setImageSendLockReady() {
        isReadyImageSend = true;
        System.out.println("notifying threads image send...");
        if(isThreadInWaitImageSend) {
            synchronized (imageSendLock) {
                imageSendLock.notifyAll();
            }
        }
        System.out.println("threads notifyed image send...");

        isThreadInWaitImageSend = false;
    }

    private void waitUntilImageSendLockNotify() {
        isThreadInWaitImageSend = true;
        System.out.println("thread in wait() image send");
        synchronized (imageSendLock) {
            while(!isReadyImageSend){
                try {
                    imageSendLock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    return;
                }
            }
        }
        System.out.println("thread AFTER wait()");
    }*/

    /*private void notifyImageSenderThread() {
        synchronized (imageSendLock) {
            imageSendLock.notify();
        }
    }

    private void lockImageSenderThread() {
        synchronized (imageSendLock) {
            try {
                imageSendLock.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }*/
    /*private void sendByteReceiveReadySignal(){
        ByteReceiveReadySignal signal = new ByteReceiveReadySignal(UserID.getUserID(),networkClientEntity.getID());
        if(!isReady) {
            unsafeSendPlainText(signal.toString());
        } else {
            sendPlainText(signal.toString());
        }
    }*/

    /*private void sendDrawImageCommandUnsafe(DrawImageCommand command) {
            command.setImageSize(command.getImageBytes().length);
            unsafeSendPlainText(command.toString());
            try {
                Sleep.sleep(400);
                sendByteArrayUnsafe(command.getImageBytes());
            } catch (IOException e) {
                e.printStackTrace();
                handleScannerClose();
            }
    }*/



//FOR DEBUG PURPUSES
        if (IP == null)
            IP = "127.0.0.1";
        if (port == -1) {
            if (startMode == 2)
                port = 2222;
            if (startMode == 0)
                port = 2223;
            if (startMode == 1)
                port = 2222;
        }

        if (startMode == 2) {
            NetworkService.prepareReceievingConnections(2222);
        } else if (startMode == 1) {
            NetworkService.prepareReceievingConnections(2223);
            //NetworkService.connect("127.0.0.1", 2223);f
            /*try {
                NetworkService.connect(IP, 2222);
            } catch (IOException e) {
                System.out.println("failed to connect in startMode 1");
            }*/
        } else if (startMode == 0) {
            NetworkService.prepareReceievingConnections(2224);
            try {
                NetworkService.connect(IP, 2223);
            } catch (IOException e) {
                System.out.println("failed to connect in startMode 0");
            }
        } else if (startMode == -1) {
            NetworkService.prepareReceievingConnections(2225);
            try {
                NetworkService.connect(IP, 2223);
            } catch (IOException e) {
                System.out.println("failed to connect in startMode 4");
            }
        }